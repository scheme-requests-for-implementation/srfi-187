;;; alambda adefine --- define-macro

(define seq-str "no argument for required sequent variable")
(define fox-str "no argument for required unnamed variable")
(define key-str "no argument for required keyword variable")

(define (every-single? alist)
  (let lp ((alist alist))
    (or (null? alist)
	(and (null? (cdr (car alist)))
	     (lp (cdr alist))))))

(define (pair->gensym-pair pair)	;(a b . c) => (g1 g2 . g3)
  (if (pair? pair)
      (cons (gensym) (pair->gensym-pair (cdr pair)))
      (if (null? pair)
	  '()
	  (gensym))))

(define-macro (wow-opt n v . r)
  (cond
   ((null? r) v)
   ((or (null? (cdr r)) (null? (cddr r)))
    (let ((t (car r))
	  (ts (if (null? (cdr r)) n (cadr r))))
      `(let ((,n ,v)) (if ,t ,ts (error 'alet* "bad argument" ,n ',n ',t)))))
   (else
    (let ((t (car r)) (ts (cadr r)) (fs (caddr r)))
      `(let ((,n ,v)) (if ,t ,ts ,fs))))))

(define-macro (wow-cat-last z n d . r)
  (cond
   ((null? r)
    `(if (null? (cdr ,z))
	 (car ,z)
	 (error 'alet* "too many arguments" ,z)))
   ((or (null? (cdr r)) (null? (cddr r)))
    (let ((t (car r))
	  (ts (if (null? (cdr r)) n (cadr r))))
      `(if (null? (cdr ,z))
	   (let ((,n (car ,z)))
	     (if ,t ,ts (error 'alet* "too many argument" ,z)))
	   (error 'alet* "too many arguments" ,z))))
   (else
    (let ((t (car r)) (ts (cadr r)) (fs (caddr r)))
      `(if (null? (cdr ,z))
	   (let ((,n (car ,z)))
	     (if ,t ,ts ,fs))
	   (error 'alet* "too many arguments" ,z))))))
(define-macro (wow-cat! z n d . r)
  (cond
   ((null? r)
    `(let ((,n (car ,z))) (set! ,z (cdr ,z)) ,n))
   ((or (null? (cdr r)) (null? (cddr r)))
    (let ((t (car r))
	  (ts (if (null? (cdr r)) n (cadr r)))
	  (head (gensym))
	  (tail (gensym)))
      `(let ((,n (car ,z)))
	 (if ,t
	     (begin (set! ,z (cdr ,z)) ,ts)
	     (let lp ((,head (list ,n)) (,tail (cdr ,z)))
	       (if (null? ,tail)
		   ,d
		   (let ((,n (car ,tail)))
		     (if ,t
			 (begin (set! ,z (append (reverse ,head) (cdr ,tail)))
				,ts)
			 (lp (cons ,n ,head) (cdr ,tail))))))))))
   (else
    (let ((t (car r)) (ts (cadr r)) (fs (caddr r)))
      `(let ((,n (car ,z)))
	 (set! ,z (cdr ,z))
	 (if ,t ,ts ,fs))))))

(define (wow-key z k d)
  (let ((x (car z))
	(y (cdr z)))
    (if (null? y)
	(cons d z)
	(if (eq? k x)
	    y
	    (let lp ((head (list x (car y))) (tail (cdr y)))
	      (if (null? tail)
		  (cons d z)
		  (let ((x (car tail))
			(y (cdr tail)))
		    (if (null? y)
			(cons d z)
			(if (eq? k x)
			    (cons (car y) (append head (cdr y)))
			    (lp (cons x (cons (car y) head)) (cdr y)))))))))))
(define-macro (wow-key! z m nkf d . r)
  (let ((n (car nkf))
	(k (cadr nkf))
	(f (if (null? (cddr nkf)) 'eq? (caddr nkf)))
	(x (gensym))
	(y (gensym))
	(head (gensym))
	(tail (gensym)))
    (if (null? r)
	(if (eqv? 2 m)
	    ;; two at a time
	    `(let ((,x (car ,z))
		   (,y (cdr ,z)))
	       (if (null? ,y)
		   ,d
		   (if (,f ,k ,x)
		       (begin (set! ,z (cdr ,y)) (car ,y))
		       (let lp ((,head (list (car ,y) ,x)) (,tail (cdr ,y)))
			 (if (null? ,tail)
			     ,d
			     (let ((,x (car ,tail))
				   (,y (cdr ,tail)))
			       (if (null? ,y)
				   ,d
				   (if (,f ,k ,x)
				       (begin
					 (set! ,z (append (reverse ,head)
							  (cdr ,y)))
					 (car ,y))
				       (lp (cons (car ,y) (cons ,x ,head))
					   (cdr ,y))))))))))
	    ;; one at a time
	    `(let ((,x (car ,z))
		   (,y (cdr ,z)))
	       (if (null? ,y)
		   ,d
		   (if (,f ,k ,x)
		       (begin (set! ,z (cdr ,y)) (car ,y))
		       (let lp ((,head (list ,x)) (,tail ,y))
			 (let ((,x (car ,tail))
			       (,y (cdr ,tail)))
			   (if (null? ,y)
			       ,d
			       (if (,f ,k ,x)
				   (begin
				     (set! ,z (append (reverse ,head) (cdr ,y)))
				     (car ,y))
				   (lp (cons ,x ,head) ,y)))))))))
	(let* ((t (car r))
	       (ts (if (null? (cdr r)) n (cadr r)))
	       (fs (if (or (null? (cdr r)) (null? (cddr r)))
		       `(error 'alet* "bad argument" ,n ',n ',t)
		       (caddr r))))
	  (if (eqv? 2 m)
	      ;; two at a time
	      `(let ((,x (car ,z))
		     (,y (cdr ,z)))
		 (if (null? ,y)
		     ,d
		     (if (,f ,k ,x)
			 (let ((,n (car ,y)))
			   (set! ,z (cdr ,y))
			   (if ,t ,ts ,fs))
			 (let lp ((,head (list (car ,y) ,x)) (,tail (cdr ,y)))
			   (if (null? ,tail)
			       ,d
			       (let ((,x (car ,tail))
				     (,y (cdr ,tail)))
				 (if (null? ,y)
				     ,d
				     (if (,f ,k ,x)
					 (let ((,n (car ,y)))
					   (set! ,z (append (reverse ,head)
							    (cdr ,y)))
					   (if ,t ,ts ,fs))
					 (lp (cons (car ,y) (cons ,x ,head))
					     (cdr ,y))))))))))
	      ;; one at a time
	      `(let ((,x (car ,z))
		     (,y (cdr ,z)))
		 (if (null? ,y)
		     ,d
		     (if (,f ,k ,x)
			 (let ((,n (car ,y)))
			   (set! ,z (cdr ,y))
			   (if ,t ,ts ,fs))
			 (let lp ((,head (list ,x)) (,tail ,y))
			   (let ((,x (car ,tail))
				 (,y (cdr ,tail)))
			     (if (null? ,y)
				 ,d
				 (if (,f ,k ,x)
				     (let ((,n (car ,y)))
				       (set! ,z (append (reverse ,head) (cdr ,y)))
				       (if ,t ,ts ,fs))
				     (lp (cons ,x ,head) ,y)))))))))))))

(define-macro (alambda pattern . body)
  (define (lamb df req rem pattern bd)
    (cond
     ((null? pattern)
      (if (null? rem)
	  (if (every-single? req)
	      `(lambda ,(map car req) ,@bd)
	      (let* ((vs (map car req))
		     (gen-vs (pair->gensym-pair vs)))
		`(lambda ,gen-vs
		   (let* ,(map (lambda (v g t) `(,v (wow-opt ,v ,g ,@t))) vs gen-vs (map cdr req))
		     ,@bd))))
	  (let ((z (car rem)))
	    `(if (null? ,z)
		 (let () ,@bd)
		 (error 'alambda "too many arguments" ,z)))))
     ((symbol? pattern)
      (if (null? rem)
	  (if (every-single? req)
	      `(lambda (,@(map car req) . ,pattern) ,@bd)
	      (let* ((vs (map car req))
		     (gen-vs (pair->gensym-pair vs))
		     (gv (gensym)))
		`(lambda (,@gen-vs . ,gv)
		   (let* (,@(map (lambda (v g t) `(,v (wow-opt ,v ,g ,@t))) vs gen-vs (map cdr req)) (,pattern ,gv))
		     ,@bd))))
	  `(let ((,pattern ,(car rem))) ,@bd)))
     (else
      (let ((vars (car pattern)))
	(cond
	 ((symbol? vars)
	  (if (null? rem)
	      (lamb df (append req (list (list vars))) rem (cdr pattern) bd)
	      (let ((y (gensym))
		    (z (car rem)))
		(if (null? df)
		    `(let ((,y (if (null? ,z) ,z (cdr ,z)))
			   (,vars (if (null? ,z) (error 'alambda ,seq-str ',vars) (car ,z))))
		       ,(lamb df req (list y) (cdr pattern) bd))
		    `(let ((,y (if (null? ,z) ,z (cdr ,z)))
			   (,vars (if (null? ,z) ,(car df) (car ,z))))
		       ,(lamb df req (list y) (cdr pattern) bd))))))
	 ((null? vars)			;()
	  (if (null? df)
	      (if (null? rem)
		  (let ((z (gensym)))
		    (if (every-single? req)
			`(lambda (,@(map car req) . ,z)
			   ,(lamb (list #f) '() (list z) (cdr pattern) bd))
			(let* ((vs (map car req))
			       (gen-vs (pair->gensym-pair vs)))
			  `(lambda (,@gen-vs . ,z)
			     (let* ,(map (lambda (v g t) `(,v (wow-opt ,v ,g ,@t))) vs gen-vs (map cdr req))
			       ,(lamb (list #f) '() (list z) (cdr pattern) bd))))))
		  (lamb (list #f) req rem (cdr pattern) bd))
	      `(error 'alambda "incorrect syntax" ',vars)))
	 ((null? (cdr vars))	   ;(default) or (('n k f ...)) ((`n k f ...))
	  (cond
	   ((and (pair? (car vars)) (pair? (caar vars)) (eq? 'quote (caaar vars)))
	    (let* ((var (car vars))
		   (v (car var))
		   (n (cadr v)))	;(('n k f ...))
	      (if (null? rem)
		  (let ((z (gensym))
			(vs (map car req)))
		    (if (every-single? req)
			`(lambda (,@vs . ,z)
			   (let ((,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 2 (,n ,@(cdr var)) (error 'alambda ,key-str ',n)))))
			     ,(lamb df '() (list z) (cdr pattern) bd)))
			(let ((gen-vs (pair->gensym-pair vs)))
			  `(lambda (,@gen-vs . ,z)
			     (let* (,@(map (lambda (v g t) `(,v (wow-opt ,v ,g ,@t))) vs gen-vs (map cdr req))
				    (,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 2 (,n ,@(cdr var)) (error 'alambda ,key-str ',n)))))
			       ,(lamb df '() (list z) (cdr pattern) bd))))))
		  (let ((z (car rem)))
		    (if (null? df)
			`(let ((,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 2 (,n ,@(cdr var)) (error 'alambda ,key-str ',n)))))
			   ,(lamb df req rem (cdr pattern) bd))
			`(let ((,n (if (null? ,z) ,(car df) (wow-key! ,z 2 (,n ,@(cdr var)) ,(car df)))))
			   ,(lamb df req rem (cdr pattern) bd)))))))
	   ((and (pair? (car vars)) (pair? (caar vars)) (eq? 'quasiquote (caaar vars)))
	    (let* ((var (car vars))
		   (v (car var))
		   (n (cadr v)))	;((`n k f ...))
	      (if (null? rem)
		  (let ((z (gensym))
			(vs (map car req)))
		    (if (every-single? req)
			`(lambda (,@vs . ,z)
			   (let ((,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 1 (,n ,@(cdr var)) (error 'alambda ,key-str ',n)))))
			     ,(lamb df '() (list z) (cdr pattern) bd)))
			(let ((gen-vs (pair->gensym-pair vs)))
			  `(lambda (,@gen-vs . ,z)
			     (let* (,@(map (lambda (v g t) `(,v (wow-opt ,v ,g ,@t))) vs gen-vs (map cdr req))
				    (,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 1 (,n ,@(cdr var)) (error 'alambda ,key-str ',n)))))
			       ,(lamb df '() (list z) (cdr pattern) bd))))))
		  (let ((z (car rem)))
		    (if (null? df)
			`(let ((,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 1 (,n ,@(cdr var)) (error 'alambda ,key-str ',n)))))
			   ,(lamb df req rem (cdr pattern) bd))
			`(let ((,n (if (null? ,z) ,(car df) (wow-key! ,z 1 (,n ,@(cdr var)) ,(car df)))))
			   ,(lamb df req rem (cdr pattern) bd)))))))
	   (else
	    (let ((var (car vars)))
	      (if (null? df)
		  (if (null? rem)
		      (let ((z (gensym)))
			(if (every-single? req)
			    `(lambda (,@(map car req) . ,z)
			       ,(lamb (list var) '() (list z) (cdr pattern) bd))
			    (let* ((vs (map car req))
				   (gen-vs (pair->gensym-pair vs)))
			      `(lambda (,@gen-vs . ,z)
				 (let* ,(map (lambda (v g t) `(,v (wow-opt ,v ,g ,@t))) vs gen-vs (map cdr req))
				   ,(lamb (list var) '() (list z) (cdr pattern) bd))))))
		      (lamb (list var) req rem (cdr pattern) bd))
		  `(error 'alambda "incorrect syntax" ',vars))))))
	 (else
	  (let ((var (car vars)))
	    (cond
	     ((eq? 'unquote var)	;,n
	      (let ((n (cadr vars)))
		(if (null? rem)
		    (let ((z (gensym))
			  (vs (map car req)))
		      (if (every-single? req)
			  `(lambda (,@vs . ,z)
			     (let ((,n (if (null? ,z) (error 'alambda ,fox-str ',n) (wow-cat! ,z ,n (error 'alambda ,fox-str ',n)))))
			       ,(lamb df '() (list z) (cdr pattern) bd)))
			  (let ((gen-vs (pair->gensym-pair vs)))
			    `(lambda (,@gen-vs . ,z)
			       (let* (,@(map (lambda (v g t) `(,v (wow-opt ,v ,g ,@t))) vs gen-vs (map cdr req))
				      (,n (if (null? ,z) (error 'alambda ,fox-str ',n) (wow-cat! ,z ,n (error 'alambda ,fox-str ',n)))))
				 ,(lamb df '() (list z) (cdr pattern) bd))))))
		    (let ((z (car rem)))
		      (if (null? df)
			  `(let ((,n (if (null? ,z) (error 'alambda ,fox-str ',n) (wow-cat! ,z ,n (error 'alambda ,fox-str ',n)))))
			     ,(lamb df req rem (cdr pattern) bd))
			  `(let ((,n (if (null? ,z) ,(car df) (wow-cat! ,z ,n ,(car df)))))
			     ,(lamb df req rem (cdr pattern) bd)))))))
	     ((eq? 'quote var)		;'n
	      (let ((n (cadr vars)))
		(if (null? rem)
		    (let ((z (gensym))
			  (vs (map car req)))
		      (if (every-single? req)
			  `(lambda (,@vs . ,z)
			     (let ((,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 2 (,n ',n eq?) (error 'alambda ,key-str ',n)))))
			       ,(lamb df '() (list z) (cdr pattern) bd)))
			  (let ((gen-vs (pair->gensym-pair vs)))
			    `(lambda (,@gen-vs . ,z)
			       (let* (,@(map (lambda (v g t) `(,v (wow-opt ,v ,g ,@t))) vs gen-vs (map cdr req))
				      (,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 2 (,n ',n eq?) (error 'alambda ,key-str ',n)))))
				 ,(lamb df '() (list z) (cdr pattern) bd))))))
		    (let ((z (car rem)))
		      (if (null? df)
			  `(let ((,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 2 (,n ',n eq?) (error 'alambda ,key-str ',n)))))
			     ,(lamb df req rem (cdr pattern) bd))
			  `(let ((,n (if (null? ,z) ,(car df) (wow-key! ,z 2 (,n ',n eq?) ,(car df)))))
			     ,(lamb df req rem (cdr pattern) bd)))))))
	     ((eq? 'quasiquote var)	;`n
	      (let ((n (cadr vars)))
		(if (null? rem)
		    (let ((z (gensym))
			  (vs (map car req)))
		      (if (every-single? req)
			  `(lambda (,@vs . ,z)
			     (let ((,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 1 (,n ',n eq?) (error 'alambda ,key-str ',n)))))
			       ,(lamb df '() (list z) (cdr pattern) bd)))
			  (let ((gen-vs (pair->gensym-pair vs)))
			    `(lambda (,@gen-vs . ,z)
			       (let* (,@(map (lambda (v g t) `(,v (wow-opt ,v ,g ,@t))) vs gen-vs (map cdr req))
				      (,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 1 (,n ',n eq?) (error 'alambda ,key-str ',n)))))
				 ,(lamb df '() (list z) (cdr pattern) bd))))))
		    (let ((z (car rem)))
		      (if (null? df)
			  `(let ((,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 1 (,n ',n eq?) (error 'alambda ,key-str ',n)))))
			     ,(lamb df req rem (cdr pattern) bd))
			  `(let ((,n (if (null? ,z) ,(car df) (wow-key! ,z 1 (,n ',n eq?) ,(car df)))))
			     ,(lamb df req rem (cdr pattern) bd)))))))
	     ((symbol? var)		;(n t ts ...) or (n d t ...)
	      (if (null? rem)
		  (lamb df (append req (list vars)) rem (cdr pattern) bd)
		  (let ((y (gensym)) (z (car rem)))
		    (if (null? df)
			`(let ((,y (if (null? ,z) ,z (cdr ,z)))
			       (,var (if (null? ,z) (error 'alambda ,seq-str ',var)  (wow-opt ,var (car ,z) ,@(cdr vars)))))
			   ,(lamb df req (list y) (cdr pattern) bd))
			`(let ((,y (if (null? ,z) ,z (cdr ,z)))
			       (,var (if (null? ,z) ,(cadr vars) (wow-opt ,var (car ,z) ,@(cddr vars)))))
			   ,(lamb df req (list y) (cdr pattern) bd))))))
	     (else
	      (let ((v (car var)))
		(cond
		 ((and (eq? 'unquote v) (null? (cdr pattern)))
		  (let ((n (cadr var)))
		    (if (null? rem)
			(let ((vs (map car req))
			      (z (gensym)))
			  (if (every-single? req)
			      `(lambda (,@vs . ,z)
				 (let ((,n (if (null? ,z) (error 'alambda ,fox-str ',n) (wow-cat-last ,z ,n (error 'alambda ,fox-str ',n) ,@(cdr vars)))))
				   ,@bd))
			      (let ((gen-vs (pair->gensym-pair vs)))
				`(lambda (,@gen-vs . ,z)
				   (let* (,@(map (lambda (v g t) `(,v (wow-opt ,v ,g ,@t))) vs gen-vs (map cdr req))
					  (,n (if (null? ,z) (error 'alambda ,fox-str ',n) (wow-cat-last ,z ,n (error 'alambda ,fox-str ',n) ,@(cdr vars)))))
				     ,@bd)))))
			(let ((z (car rem)))
			  (if (null? df)
			      `(let ((,n (if (null? ,z) (error 'alambda ,fox-str ',n) (wow-cat-last ,z ,n (error 'alambda ,fox-str ',n) ,@(cdr vars)))))
				 ,@bd)
			      `(let ((,n (if (null? ,z) ,(cadr vars) (wow-cat-last ,z ,n ,@(cdr vars)))))
				 ,@bd))))))
		 ((eq? 'unquote v)	;(,n t ts ...) or (,n d t ...)
		  (let ((n (cadr var)))
		    (if (null? rem)
			(let ((vs (map car req))
			      (z (gensym)))
			  (if (every-single? req)
			      `(lambda (,@vs . ,z)
				 (let ((,n (if (null? ,z) (error 'alambda ,fox-str ',n) (wow-cat! ,z ,n (error 'alambda ,fox-str ',n) ,@(cdr vars)))))
				   ,(lamb df '() (list z) (cdr pattern) bd)))
			      (let ((gen-vs (pair->gensym-pair vs)))
				`(lambda (,@gen-vs . ,z)
				   (let* (,@(map (lambda (v g t) `(,v (wow-opt ,v ,g ,@t))) vs gen-vs (map cdr req))
					  (,n (if (null? ,z) (error 'alambda ,fox-str ',n) (wow-cat! ,z ,n (error 'alambda ,fox-str ',n) ,@(cdr vars)))))
				     ,(lamb df '() (list z) (cdr pattern) bd))))))
			(let ((z (car rem)))
			  (if (null? df)
			      `(let ((,n (if (null? ,z) (error 'alambda ,fox-str ',n) (wow-cat! ,z ,n (error 'alambda ,fox-str ',n) ,@(cdr vars)))))
				 ,(lamb df req rem (cdr pattern) bd))
			      `(let ((,n (if (null? ,z) ,(cadr vars) (wow-cat! ,z ,n ,@(cdr vars)))))
				 ,(lamb df req rem (cdr pattern) bd)))))))
		 ((eq? 'quote v)	;('n t ts ...) or ('n d t ...)
		  (let ((n (cadr var)))
		    (if (null? rem)
			(let ((vs (map car req))
			      (z (gensym)))
			  (if (every-single? req)
			      `(lambda (,@vs . ,z)
				 (let ((,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 2 (,n ',n eq?) (error 'alambda ,key-str ',n) ,@(cdr vars)))))
				   ,(lamb df '() (list z) (cdr pattern) bd)))
			      (let ((gen-vs (pair->gensym-pair vs)))
				`(lambda (,@gen-vs . ,z)
				   (let* (,@(map (lambda (v g t) `(,v (wow-opt ,v ,g ,@t))) vs gen-vs (map cdr req))
					  (,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 2 (,n ',n eq?) (error 'alambda ,key-str ',n) ,@(cdr vars)))))
				     ,(lamb df '() (list z) (cdr pattern) bd))))))
			(let ((z (car rem)))
			  (if (null? df)
			      `(let ((,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 2 (,n ',n eq?) (error 'alambda ,key-str ',n) ,@(cdr vars)))))
				 ,(lamb df req rem (cdr pattern) bd))
			      `(let ((,n (if (null? ,z) ,(cadr vars) (wow-key! ,z 2 (,n ',n eq?) ,@(cdr vars)))))
				 ,(lamb df req rem (cdr pattern) bd)))))))
		 ((eq? 'quasiquote v)	;(`n t ts ...) or (`n d t ...)
		  (let ((n (cadr var)))
		    (if (null? rem)
			(let ((vs (map car req))
			      (z (gensym)))
			  (if (every-single? req)
			      `(lambda (,@vs . ,z)
				 (let ((,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 1 (,n ',n eq?) (error 'alambda ,key-str ',n) ,@(cdr vars)))))
				   ,(lamb df '() (list z) (cdr pattern) bd)))
			      (let ((gen-vs (pair->gensym-pair vs)))
				`(lambda (,@gen-vs . ,z)
				   (let* (,@(map (lambda (v g t) `(,v (wow-opt ,v ,g ,@t))) vs gen-vs (map cdr req))
					  (,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 1 (,n ',n eq?) (error 'alambda ,key-str ',n) ,@(cdr vars)))))
				     ,(lamb df '() (list z) (cdr pattern) bd))))))
			(let ((z (car rem)))
			  (if (null? df)
			      `(let ((,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 1 (,n ',n eq?) (error 'alambda ,key-str ',n) ,@(cdr vars)))))
				 ,(lamb df req rem (cdr pattern) bd))
			      `(let ((,n (if (null? ,z) ,(cadr vars) (wow-key! ,z 1 (,n ',n eq?) ,@(cdr vars)))))
				 ,(lamb df req rem (cdr pattern) bd)))))))
		 ((and (symbol? v) (null? (cddr var)) (null? (cddr vars)) (pair? df)) ;((n k) d)
		  (let ((z (car rem))
			(d (cadr vars)))
		    `(let* ((,z (if (null? ,z)
				    (cons ,d ,z)
				    (wow-key ,z ,(cadr var) ,d)))
			    (,v (car ,z))
			    (,z (cdr ,z)))
		       ,(lamb df req (list z) (cdr pattern) bd))))
		 ((and (pair? v) (eq? 'quote (car v))) ;(('n k f ...) x y ...)
		  (let ((n (cadr v)))
		    (if (null? rem)
			(let ((z (gensym))
			      (vs (map car req)))
			  (if (every-single? req)
			      `(lambda (,@vs . ,z)
				 (let ((,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 2 (,n ,@(cdr var)) (error 'alambda ,key-str ',n) ,@(cdr vars)))))
				   ,(lamb df '() (list z) (cdr pattern) bd)))
			      (let ((gen-vs (pair->gensym-pair vs)))
				`(lambda (,@gen-vs . ,z)
				   (let* (,@(map (lambda (v g t) `(,v (wow-opt ,v ,g ,@t))) vs gen-vs (map cdr req))
					  (,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 2 (,n ,@(cdr var)) (error 'alambda ,key-str ',n) ,@(cdr vars)))))
				     ,(lamb df '() (list z) (cdr pattern) bd))))))
			(let ((z (car rem)))
			  (if (null? df)
			      `(let ((,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 2 (,n ,@(cdr var)) (error 'alambda ,key-str ',n) ,@(cdr vars)))))
				 ,(lamb df req rem (cdr pattern) bd))
			      `(let ((,n (if (null? ,z) ,(cadr vars) (wow-key! ,z 2 (,n ,@(cdr var)) ,@(cdr vars)))))
				 ,(lamb df req rem (cdr pattern) bd)))))))
		 ((and (pair? v) (eq? 'quasiquote (car v)))
		  (let ((n (cadr v)))
		    (if (null? rem)
			(let ((z (gensym))
			      (vs (map car req)))
			  (if (every-single? req)
			      `(lambda (,@vs . ,z)
				 (let ((,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 1 (,n ,@(cdr var)) (error 'alambda ,key-str ',n) ,@(cdr vars)))))
				   ,(lamb df '() (list z) (cdr pattern) bd)))
			      (let ((gen-vs (pair->gensym-pair vs)))
				`(lambda (,@gen-vs . ,z)
				   (let* (,@(map (lambda (v g t) `(,v (wow-opt ,v ,g ,@t))) vs gen-vs (map cdr req))
					  (,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 1 (,n ,@(cdr var)) (error 'alambda ,key-str ',n) ,@(cdr vars)))))
				     ,(lamb df '() (list z) (cdr pattern) bd))))))
			(let ((z (car rem)))
			  (if (null? df)
			      `(let ((,n (if (null? ,z) (error 'alambda ,key-str ',n) (wow-key! ,z 1 (,n ,@(cdr var)) (error 'alambda ,key-str ',n) ,@(cdr vars)))))
				 ,(lamb df req rem (cdr pattern) bd))
			      `(let ((,n (if (null? ,z) ,(cadr vars) (wow-key! ,z 1 (,n ,@(cdr var)) ,@(cdr vars)))))
				 ,(lamb df req rem (cdr pattern) bd)))))))
		 (else `(error 'alambda "incorrect syntax" ',vars)))))))))))))
  (lamb '() '() '() pattern body))

(define-macro (adefine pattern . body)
  (if (pair? pattern)
      `(define ,(car pattern) (alambda ,(cdr pattern) ,@body))
      `(define ,pattern ,@body)))

;;; eof
